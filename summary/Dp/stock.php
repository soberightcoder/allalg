<?php

/**
 *  股票方面的动态规划；
 *  股票买卖是最经典的系列；动态规划是这一些列股票买卖的经典解决方案；
 *  动态规划 是股票问题的一个通用解法；
 *  注意这是同一个公司的股票，$prices[$i] 代表的是第$i天的价格； 
 * // 第i天有可能啥也不做，也有可能 买了股票 就是这个意思；
 *  持有股票也就是以前买过这一股股票$dp[$i - 1][0] 第i天什么也没干；，或者是当天直接买这股票；第i天买这个股票；
 * // 总结 下面的： 第i天有可能啥都不做，有可能卖出股票；
 *  不持有股票，代表股票，早已经卖出去了$dp[$i - 1][1]；或者当天卖出去； $dp[$i - 1][0]（第i-1天持有股票） + $prices[$i](第i天卖出)
 *  */

/**
 * 关于股票方面的动态规划
 * 股票问题基本全部都可以用动态规划来解决；
 *  */


/**
 * 121. 买卖股票的最佳时机I
 *  */

class Solution121
{

    /**
     * @param Integer[] $prices
     * @return Integer
     */
    /**
     *  也可以暴力求解，一次是买股票的地方，一次是卖股票的地方，求出所有的情况的最大值；
     *  时间复杂度是n^2
     */
    //只能买一次； 股票只能买一次 卖一次！！！
    function maxProfit($prices)
    {
        // 如果只用一维数组的dp 很难表示$i天的状态（持有股票）；
        // $dp[$i][0]代表的是持有股票所得最多现金；(持有股票，现金就会变成负数；)  $dp[$i][1]不持有股票（包含了当天卖出股票）所得最多现金；(计算差值吗？ 收益吗？)
        // 持有股票和不持有股票，并不代表这一天进行股票的买卖；
        $n = count($prices);
        // dp 数组的初始化；
        $dp[0][0] = -$prices[0]; //买这个股票
        $dp[0][1] = 0; //不买这个股票；
        //股票买卖的递推公式； 
        //第i天持有股票的
        //注意 这里是负的； 一种保持这种状态    也有可能是第i天买入这个股票了；
        //因为0已经初始化了，所以就从1 开始了；
        for ($i = 1; $i < count($prices); $i++) {
            $dp[$i][0] = max($dp[$i - 1][0], -$prices[$i]);
            //不持有这种股票的状态；  保持不持有股票的状态；  卖出这个股票；
            $dp[$i][1] = max($dp[$i - 1][1], $dp[$i - 1][0] + $prices[$i]);
        }
        //肯定是不持有股票手上的现金多；这是必然的；因为只做了一次买卖；
        return max($dp[$n - 1][0], $dp[$n - 1][1]);
    }
}


// 贪心算法 求最大收益；
/**
 * 时间复杂度是O(n)  空间时间复杂度是O(1) 
 * 这里是怎么实现的？
 */
function stockMaxProfit($prices)
{
    //这里肯定会要保存最大值；
    $low = PHP_INT_MAX;
    $result = 0; //利润；

    for ($i = 0; $i < count($prices); $i++) {
        //保存的是最小价格；
        $low = min($low, $prices[$i]);
        //然后找最大价格；找到最大价格 更新到result；
        $result = max($result, $prices[$i] - $low);
    }

    return $result;
}
// echo stockMaxProfit([7,1,5,3,6,4]);


/**
 * 这个实现的流程是什么？
 * 因为 最小值 必须要在前面，大值要在后面，所以才能用for才能找得到呀；也就是有序的把；
 * 就是取左边的一个最小值；取右边的一个最大值；然后一减； 就可以了；
 * 这段代码之所以可以通过一次遍历找到最大利润，是因为它使用了一种叫做"贪心算法"的策略。
 * 在这个算法中，我们通过一次遍历股票价格数组，同时记录最低价格和最大利润。我们假设最低价格就是当前遍历到的价格，然后计算当前价格与最低价格的差值，即当前可能的最大利润。如果这个差值比之前记录的最大利润还要大，那么我们就更新最大利润的值。这样，通过一次遍历，我们就可以找到最佳的买入和卖出时机，从而获得最大的利润。
 * 这种贪心算法的原理在于，我们不需要考虑所有可能的买入和卖出组合，而是在遍历过程中始终保持最低价格和最大利润的更新，从而找到最佳的买入和卖出时机。这样可以在一次遍历中找到最大利润，提高了算法的效率。
 */

/**
 * 这个思路是真的牛；
 * 可以把股票的价格波动画出来，单调上升就是盈利，题解就是每一段单调上升的总和[doge]
 * [2,9,1,7];  最小的时候并不一定就是收益是最大的；
 */
function stockMaxProfit1($prices)
{
    $minprice = PHP_INT_MAX;
    $maxprofit = 0;
    for ($i = 0; $i < count($prices); $i++) {
        if ($prices[$i] < $minprice) {
            //保存最小价格；
            $minprice = $prices[$i];
        } else if ($prices[$i] - $minprice > $maxprofit) {
            $maxprofit = $prices[$i] - $minprice;
        }
    }
    return $maxprofit;
}
// echo stockMaxProfit1([7,1,5,3,6,4]);
// echo stockMaxProfit1([9,3,12,1,2,3]);


/**
 * 卖卖股票II  --- 122
 * //第一次买卖股票 初始现金一定是0；
 *  */



class Solution122
{

    /**
     * @param Integer[] $prices
     * @return Integer
     */
    function maxProfit($prices)
    {
        // 贪心算法； 画一个图；把所有的利润加起来就好了；
        // $result = 0;
        // for ($i = 1; $i < count($prices); $i++) {
        //     $result += max($prices[$i] - $prices[$i - 1],0);
        // }
        // return $result;
        $n = count($prices);
        //第一天持有股票；注意是这边是负数，因为一开始现金是0；
        $dp[0][0] = -$prices[0];
        //第一天不持有股票；
        $dp[0][1] = 0;
        //递归公式；
        //           第i天啥也没做继承上一天的财产     第i天不持有股票的财产 + 购买股票减去的财产；
        for ($i = 1; $i < $n; $i++) {
            //股票可以买卖一次 和股票可以买卖多次的区别在哪里？买卖多次 手动上的现金，是前一天不持有股票的现金 减去 价格； 如果是只进行一次的买卖，那么开始现金就是0； 所以仅仅是-$prices[$i]
            //持有股票
            $dp[$i][0] = max($dp[$i - 1][0], $dp[$i - 1][1] - $prices[$i]);
            //不持有股票；
            $dp[$i][1] = max($dp[$i - 1][1], $dp[$i - 1][0] + $prices[$i]);
        }
        return max($dp[$n - 1][0], $dp[$n - 1][1]);
        // return $dp[$n - 1][1];
    }
}


// $obj122 = new Solution122();
// echo $obj122->maxProfit([7,1,5,3,6,4]);


/**
 * 
 * 123. 买卖股票的最佳时机 III
 * 你至多可以完成，两笔 交易。
 * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。-- 前面多次买卖都是有这个限定条件的；
 *  */

class Solution123
{

    /**
     * @param Integer[] $prices
     * @return Integer
     */
    function maxProfit($prices)
    {

        //dp数组的含义；
        //  $dp[$i][0] 不操作； 
        // $dp[$i][1] 第n天第一次持有股票；
        // $dp[$i][2]  第一次不持有；
        // $dp[$i][3] 第二次持有股票；
        //$dp[$i][4] 第二次不持有；
        $n = count($prices);
        // dp init
        $dp[0][0] = 0;//未进行一次操作； 也就是不操作；可以一直处于未操作的状态呀； 比如 8 7 6 4  2 1 不就等于0吗？
        $dp[0][1] = -$prices[0];
        $dp[0][2] = 0;
        $dp[0][3] = -$prices[0];
        $dp[0][4] = 0;

        //递推公式
        //不做任何的操作；

        for ($i = 1; $i < $n; $i++) {
            $dp[$i][0] = $dp[$i - 1][0];
            //第一次持有股票；  //一直持有；               第i天这天买股票； 肯定是前一天没有做任何的操作；
            $dp[$i][1] = max($dp[$i - 1][1], $dp[$i - 1][0] - $prices[$i]);
            //第一次不持有股票；  延续前面的状态；
            $dp[$i][2] = max($dp[$i - 1][2], $dp[$i - 1][1] + $prices[$i]);
            //第二次持有股票；
            $dp[$i][3] = max($dp[$i - 1][3], $dp[$i - 1][2] - $prices[$i]);
            //第二次不持有股票；
            $dp[$i][4] = max($dp[$i - 1][4], $dp[$i - 1][3] + $prices[$i]);
        }

        return max($dp[$n - 1][4], $dp[$n - 1][2]);
    }
}
$obj123 = new Solution123();
// echo $obj123->maxProfit([8,7,6,5,4,3,2,1]);// 这里就是0，根本就没有做过操作；



/**
 * 
 * 188. 买卖股票的最佳时机 IV
 * 动态规划来决定最佳时机，至多可以买卖K次！和上面买卖K次的区别？
 * 
 */

class Solution188
{

    /**
     * @param Integer $k
     * @param Integer[] $prices
     * @return Integer
     */
    function maxProfit($k, $prices)
    {

        //dp数组的含义；
        //  $dp[$i][0] 不操作； 
        // $dp[$i][1] 第n天第一次持有股票；
        // $dp[$i][2]  第一次不持有；
        // $dp[$i][3] 第二次持有股票；
        //$dp[$i][4] 第二次不持有；
        $n = count($prices);
        // dp init
        $dp[0][0] = 0;
        // $dp[0][1] = -$prices[0];
        // $dp[0][2] = 0;
        // $dp[0][3] = -$prices[0];
        // $dp[0][4] = 0;
        //init
        for ($j = 1; $j <= (2 * $k);) {
            $dp[0][$j] = -$prices[0];
            $dp[0][$j + 1] = 0;
            $j += 2;
        }
        // var_dump($dp);die;
        //递推公式
        //不做任何的操作；

        for ($i = 1; $i < $n; $i++) {
            $dp[$i][0] = $dp[$i - 1][0];
            for ($j = 1; $j <= 2 * $k; $j += 2) {
                //这边有问题；
                //第一次持有股票；  //一直持有；               第i天这天买股票； 肯定是前一天没有做任何的操作；
                $dp[$i][$j] = max($dp[$i - 1][$j], $dp[$i - 1][$j - 1] - $prices[$i]);
                //第一次不持有股票；  延续前面的状态；
                $dp[$i][$j + 1] = max($dp[$i - 1][$j + 1], $dp[$i - 1][$j] + $prices[$i]);
                //第二次持有股票；
            }
        }

        return $dp[$n - 1][2 * $k];
    }
}
// $obj = new Solution188();
// echo $obj->maxProfit(2,[2,4,1]);

/***
 * 动态规划来决定最佳时机，这次有冷冻期！|  在股票买卖时机II的基础上加上一个冷却期；
 * LeetCode：309.买卖股票的最佳时机含冷冻期
 * 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
 * 这个就是最难的，带有冷冻期的操作；
 */

class Solution309
{

    /**
     * @param Integer[] $prices
     * @return Integer
     */
    function maxProfit($prices)
    {
        //dp状态；
        //持有股票的状态；

        //$dp[$i][0]持有股票的状态；
        //这里的「处于冷冻期」指的是在第 iii 天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。
        //$dp[$i][1] 不持有股票冷却期股票的累计最大收益；
        //$dp[$i][2] 不持有股票不是冷却期股票的累计最大收益；

        $n = count($prices);
        $dp[0][0] = -$prices[0];
        $dp[0][1] = 0;
        $dp[0][2] = 0;
        //1 持有股票的状态；
        for ($i = 1; $i < $n; $i++) {
            // 没有做任何的操作  第一次的持有买股票；
            $dp[$i][0] = max($dp[$i - 1][0], $dp[$i - 1][2] - $prices[$i]);
            //2 不持有股票的状态；i天没有任何的操作；
            $dp[$i][1] = $dp[$i - 1][0] + $prices[$i];
                            //冷冻期的收益    // 不是冷冻期的收益；
            $dp[$i][2] = max($dp[$i - 1][1],$dp[$i - 1][2]);
        }
        return max($dp[$n - 1][1],$dp[$n-1][2]);
        
    }

}


/**
 * 
 * 动态规划来决定最佳时机，这次含手续费！| 
 * LeetCode：714.买卖股票的最佳时机含手续费
 * 包含手续费，和买卖股票II的比较；
 */

 class Solution14 {

    /**
     * @param Integer[] $prices
     * @param Integer $fee
     * @return Integer
     */
    function maxProfit($prices, $fee) {
        //dp数组 持有股票和不持有股票这两个状态；

        $n = count($prices);
        // dp数组  
        //init dp
        $dp[0][0] = -$prices[0];
        $dp[0][1] = 0;
        for ($i = 1; $i < $n; $i++) {
        //递推公式；
        $dp[$i][0] = max($dp[$i - 1][0],$dp[$i - 1][1] - $prices[$i]);
        //print
        $dp[$i][1] = max($dp[$i - 1][1], $dp[$i - 1][0] + $prices[$i] - $fee);

        }
        return $dp[$n - 1][1];
    }
}


/**
 * 股票的总结：
 * 数组中只能买卖一次；
 * 持有股票的状态；
 * 不持有股票的状态； 
 */
